//
// Top-level
//

program = {
    SOI
    ~ ^"program" ~ identifier ~ ";"
    ~ (decl ~ ";")*
    ~ ^"begin"
    ~ ^"end."
    ~ EOI
}

//
// Declarations
//

/// A top-level declaration.
decl = {
    constraint_decl
    | procedure_decl
    | view_decl
}

//
// Constraints
//

/// A constraint declaration.
constraint_decl = {
    ^"constraint"
    ~ view_pattern ~ ("," ~ view_pattern)*
    ~ constraint
}

// The body of a constraint.
constraint = {
    entails_constraint
}

// A constraint that maps a view pattern to a Boolean expression.
entails_constraint = {
    ^"entails" ~ expr
}

//
// View patterns
//

view_pattern = {
    empty_view
    | (view_pattern_atom ~ ("*" ~ view_pattern_atom)*)
}

view_pattern_atom = {
    identifier ~ view_pattern_argument_list? ~ iterator_pattern?
}

/// A view argument pattern list.
view_pattern_argument_list = {
    "("
    ~ view_pattern_argument
    ~ ("," ~ view_pattern_argument)*
    ~ ")"
}

/// A view iterator pattern.
iterator_pattern = {
    "[" ~ view_pattern_argument ~ "]"
}

view_pattern_argument = _{
    wildcard
    | expr
}

wildcard = { "_" }
empty_view = { ^"emp" }

//
// View assertions
//

view_assertion = {
    empty_view
    | (view_atom_assertion ~ ("*" ~ view_atom_assertion)*)
}

view_atom_assertion = {
    call_expression ~ view_iterator?
}

/// A view iterator (modelled as a subscript).
view_iterator = {
    subscript
}

//
// View decls
//

// A decl for one or more view atoms.
view_decl = {
    ^"view"
    ~ view_decl_list
}

// A list of view decl elements.
view_decl_list = {
    prototype
    ~ ("," ~ prototype)*
}

//
// Procedure decls
//

procedure_decl = {
    "procedure"
    ~ prototype
    ~ ";"
    ~ "begin"
    ~ statement_list
    ~ "end"
}

//
// Function and view prototypes
//

prototype = {
    identifier ~ parameter_list?
}

parameter_list = {
    "("
    ~ (parameter ~ ("," ~ parameter)*)?
    ~ ")"
}

parameter = {
    identifier ~ ":" ~ starling_type
}

//
// Types
//

starling_type = {
    primitive_type
    | identifier
    | refinement_type
    | array_type
}

// A refinement type, of the form "{x : T | P(x)}".
refinement_type = {
    "{"
    ~ identifier
    ~ ":"
    ~ starling_type
    ~ "|"
    ~ expr
}

// An array type.
array_type = {
    "array"
    ~ "["
    ~ array_bound
    ~ "]"
    ~ "of"
    ~ starling_type
}

// Bounds for an array type.
array_bound = {
    int_literal
    ~ ".."
    ~ int_literal
}

primitive_type = {
    ^"boolean"
    | ^"integer"
}

//
// Statements
//

/// A semicolon-separated (Pascal-style) list of statements.
statement_list = {
    (statement_with_views ~ (";" ~ statement_with_views)*)?
}

/// A statement that is optionally surrounded with view expressions.
statement_with_views = _{
    view_assertion? ~ statement ~ view_assertion?
}

/// A statement.
statement = {
    postfix_statement
}

postfix_statement = _{
    identifier ~ postfix_op
}

postfix_op = {
    "++"
    | "--"
}

//
// Expressions (Pratt parsing)
//

/// Expressions.
expr = !{ prefix* ~ primary~ postfix* ~ (infix ~ prefix* ~ primary~ postfix* )* }

// The operators are broadly those allowed by

infix =  _{ arith_op | bool_op | rel_op }

arith_op = _{ add | sub | mul | div | int_div | modulus }
add      =  { "+" }
sub      =  { "-" }
mul      =  { "*" }
div      =  { "/" }
int_div  =  { ^"div" }
modulus  =  { ^"mod" }

bool_op  = _{ and | or | implies | iff }
and      =  { ^"and" }
or       =  { ^"or" }
implies  =  { ^"implies" }
iff      =  { ^"iff" }

rel_op     = _{ not_eq | less_eq | greater_eq | less | greater | eq }
less       =  { "<" }
less_eq    =  { "<=" }
eq         =  { "=" }
not_eq     =  { "<>" }
greater    =  { "<" }
greater_eq =  { "<=" }

prefix =  _{ pos | neg | not }
pos    =   { "+" }
neg    =   { "-" }
not    =   { ^"not" }

postfix   =  _{ subscript }
subscript =   { "[" ~ expr ~ "]" }

primary  =  _{ literal | identifier | call_expression | "(" ~ expr ~ ")" }

call_expression = {
    identifier ~ argument_list?
}

argument_list = {
    "("
    ~ expr
    ~ ("," ~ expr)*
    ~ ")"
}

//
// Literals
//

// Any type of literal.
literal =
    { bool_literal
    | int_literal
    }

// Boolean literal (case-insensitive true or false).
bool_literal = { ^"true" | ^"false" }

// Integer literal (decimal number, possibly with a sign).
int_literal = @{ ASCII_DIGIT+ }

// An identifier.
identifier = @{ XID_START ~ (XID_CONTINUE)* }

//
// Trivia
//

// Whitespace is ASCII spaces, tabs, or newlines.
WHITESPACE = _{ " " | "\t" | NEWLINE }

// Pascal-style comments.
COMMENT = _{ "(*" ~ (!"*)" ~ ANY)* ~ "*)" }
