//
// Top-level
//

program = {
    SOI
    ~ "program" ~ identifier ~ ";"
    ~ (decl ~ ";")*
    ~ "begin"
    ~ "end."
    ~ EOI
}

//
// Declarations
//

/// A top-level declaration.
decl = {
    constraint_decl
    | procedure_decl
    | view_decl
}

//
// Constraints
//

/// A constraint declaration.
constraint_decl = {
    "constraint"
    ~ view_pattern
    ~ constraint_body
}

// The body of a constraint.
constraint_body = {
    expression_constraint_body
}

// A constraint body that maps a view pattern to a Boolean expression.
expression_constraint_body = _{
    "entails" ~ expression
}

//
// View patterns
//

view_pattern = {
    empty_view
    | (view_atom_pattern ~ ("*" ~ view_atom_pattern)*)
}

view_atom_pattern = {
    identifier ~ view_argument_pattern_list? ~ iterator_pattern?
}

/// A view argument pattern list.
view_argument_pattern_list = _{
    "("
    ~ view_argument_pattern
    ~ ("," ~ view_argument_pattern)*
    ~ ")"
}

/// A view iterator pattern.
iterator_pattern = _{
    "[" ~ view_argument_pattern ~ "]"
}

view_argument_pattern = _{
    wildcard
    | expression
}

wildcard = { "_" }
empty_view = { "emp" }

//
// View assertions
//

view_assertion = {
    empty_view
    | (view_atom_assertion ~ ("*" ~ view_atom_assertion)*)
}

view_atom_assertion = {
    call_expression ~ view_iterator?
}

/// A view iterator (modelled as a subscript).
view_iterator = {
    subscript
}

//
// View decls
//

// A decl for one or more view atoms.
view_decl = {
    "view"
    ~ view_decl_list
}

// A list of view decl elements.
view_decl_list = {
    prototype
    ~ ("," ~ prototype)*
}

//
// Procedure decls
//

procedure_decl = {
    "procedure"
    ~ prototype
    ~ ";"
    ~ "begin"
    ~ statement_list
    ~ "end"
}

//
// Function and view prototypes
//

prototype = {
    identifier ~ parameter_list?
}

parameter_list = {
    "("
    ~ (parameter ~ ("," ~ parameter)*)?
    ~ ")"
}

parameter = {
    identifier ~ ":" ~ starling_type
}

//
// Types
//

starling_type = {
    primitive_type
    | identifier
    | refinement_type
    | array_type
}

// A refinement type, of the form "{x : T | P(x)}".
refinement_type = {
    "{"
    ~ identifier
    ~ ":"
    ~ starling_type
    ~ "|"
    ~ expression
}

// An array type.
array_type = {
    "array"
    ~ "["
    ~ array_bound
    ~ "]"
    ~ "of"
    ~ starling_type
}

// Bounds for an array type.
array_bound = {
    int_literal
    ~ ".."
    ~ int_literal
}

primitive_type = {
    "boolean"
    | "integer"
}

//
// Statements
//

/// A semicolon-separated (Pascal-style) list of statements.
statement_list = {
    (statement_with_views ~ (";" ~ statement_with_views)*)?
}

/// A statement that is optionally surrounded with view expressions.
statement_with_views = _{
    view_assertion? ~ statement ~ view_assertion?
}

/// A statement.
statement = {
    postfix_statement
}

postfix_statement = _{
    identifier ~ postfix_op
}

postfix_op = {
    "++"
    | "--"
}

//
// Expressions (Pratt parsing)
//

/// Expressions.
expression = !{ prefix* ~ primary~ postfix* ~ (infix ~ prefix* ~ primary~ postfix* )* }

infix =  _{ arith_op | bool_op | rel_op }

arith_op = _{ add | sub | mul | div | pow }
add      =  { "+" }
sub      =  { "-" }
mul      =  { "*" }
div      =  { "/" }
pow      =  { "^" }

bool_op  = _{ and | or | implies }
and      =  { "and" }
or       =  { "or" }
implies  =  { "implies" }

rel_op     = _{ not_eq | less_eq | greater_eq | less | greater | eq }
less       =  { "<" }
less_eq    =  { "<=" }
eq         =  { "=" }
not_eq     =  { "<>" }
greater    =  { "<" }
greater_eq =  { "<=" }

prefix =  _{ neg | not }
neg    =   { "-" }
not    =   { "not" }

postfix   =  _{ subscript }
subscript =   { "[" ~ expression ~ "]" }

primary  =  _{ literal | identifier | call_expression | "(" ~ expression ~ ")" }

call_expression = {
    identifier ~ argument_list?
}

argument_list = {
    "("
    ~ expression
    ~ ("," ~ expression)*
    ~ ")"
}

//
// Literals
//

// Any type of literal.
literal =
    { bool_literal
    | int_literal
    }

// Boolean literal (case-insensitive true or false).
bool_literal = { ^"true" | ^"false" }

// Integer literal (decimal number, possibly with a sign).
int_literal = { sign? ~ ASCII_DIGIT+ }

// Sign (positive or negative).
sign = { "+" | "-" }

// An identifier.
identifier = @{ XID_START ~ (XID_CONTINUE)* }

//
// Trivia
//

// Whitespace is ASCII spaces, tabs, or newlines.
WHITESPACE = _{ " " | "\t" | NEWLINE }

// Pascal-style comments.
COMMENT = _{ "(*" ~ (!"*)" ~ ANY)* ~ "*)" }
