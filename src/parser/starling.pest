//
// Top-level
//

/// A program.
program = {
    SOI
    ~ ^"program" ~ identifier ~ ";"
    ~ (decl ~ ";")*
    ~ ^"begin"
    ~ ^"end."
    ~ EOI
}


//
// Declarations
//

/// A top-level declaration.
decl = {
    constraint_decl
    | procedure_decl
    | view_decl
}


//
// Constraints
//

/// A constraint declaration.
constraint_decl = {
    ^"constraint"
    ~ view_pattern ~ ("," ~ view_pattern)*
    ~ constraint
}

// The body of a constraint.
constraint = {
    entails_constraint
}

// A constraint that maps a view pattern to a Boolean expression.
entails_constraint = {
    ^"entails" ~ expr
}


//
// View patterns
//

view_pattern = {
    empty_view
    | (view_pattern_atom ~ ("*" ~ view_pattern_atom)*)
}

view_pattern_atom = {
    identifier ~ view_pattern_argument_list? ~ iterator_pattern?
}

/// A view argument pattern list.
view_pattern_argument_list = {
    "("
    ~ view_pattern_argument
    ~ ("," ~ view_pattern_argument)*
    ~ ")"
}

/// A view iterator pattern.
iterator_pattern = {
    "^" ~ view_pattern_argument
}

view_pattern_argument = _{
    wildcard
    | expr
}

wildcard = { "_" }
empty_view = { ^"emp" }


//
// View assertions (Pratt parsing)
//

view_assertion = {
    "{" ~ view_assertion_body ~ "}"
}

/// A Pratt-parsed view assertion body.
view_assertion_body = !{
    view_prefix* ~ view_primary~ view_postfix* ~ (view_infix ~ view_prefix* ~ view_primary~ view_postfix* )*
}

view_prefix = _{
    view_guard
}
view_guard = { "[" ~ expr ~ "]" }

view_infix = _{
    view_join
    | view_ite
}
view_join = { "*" }
view_ite  = { "<[" ~ expr ~ "]>" }

view_postfix = _{
    view_iterate
}
view_iterate = { "^" ~ expr }

view_primary = _{
    "(" ~ view_assertion_body ~ ")"
    | view_assertion_atom
}
view_assertion_atom = {
    call ~ view_iterator?
}

/// A view iterator (modelled as a subscript).
view_iterator = {
    subscript
}


//
// View decls
//

// A decl for one or more view atoms.
view_decl = {
    ^"view"
    ~ view_decl_list
}

// A list of view decl elements.
view_decl_list = {
    prototype
    ~ ("," ~ prototype)*
}


//
// Procedure decls
//

procedure_decl = {
    "procedure"
    ~ prototype
    ~ ";"
    ~ "begin"
    ~ stm_list
    ~ "end"
}


//
// Function and view prototypes
//

prototype = {
    identifier ~ parameter_list?
}

parameter_list = {
    "("
    ~ (parameter ~ ("," ~ parameter)*)?
    ~ ")"
}

parameter = {
    identifier ~ ":" ~ starling_type
}


//
// Types
//

starling_type = {
    primitive_type
    | identifier
    | refinement_type
    | array_type
}

// A refinement type, of the form "{x : T | P(x)}".
refinement_type = {
    "{"
    ~ identifier
    ~ ":"
    ~ starling_type
    ~ "|"
    ~ expr
}

// An array type.
array_type = {
    "array"
    ~ "["
    ~ array_bound
    ~ "]"
    ~ "of"
    ~ starling_type
}

// Bounds for an array type.
array_bound = {
    int_literal
    ~ ".."
    ~ int_literal
}

primitive_type = {
    ^"boolean"
    | ^"integer"
}


//
// Statements
//

/// A semicolon-separated (Pascal-style) list of statements.
stm_list = {
    (stm_triple ~ (";" ~ stm_triple)*)?
}

/// A statement that is optionally surrounded with view expressions.
stm_triple = {
    view_assertion? ~ stm ~ view_assertion?
}

/// A statement.
stm = {
      atomic_stm // Atomic statement
    | call       // Procedure call
    | nop_stm
}

nop_stm = { ^"nop" }

/// A list of statements to be treated atomically.
///
/// There are two forms of atomic statement syntax: one that uses keywords in
/// the typical Pascal style, and another that uses angle brackets in an
/// approximation of typical proof script style.
atomic_stm = {
    ("<|" ~ stm_list ~ "|>")
    | (^"atomic" ~ stm_list ~ ^"end")
}


//
// Expressions (Pratt parsing)
//

/// Expressions.
expr = !{ prefix* ~ primary~ postfix* ~ (infix ~ prefix* ~ primary~ postfix* )* }

// The operators are broadly those allowed by Pascal, with some extensions to
// make specifying constraints easier.

infix =  _{ arith_op | bool_op | rel_op }

arith_op = _{ add | sub | mul | div | int_div | modulus }
add      =  { "+" }
sub      =  { "-" }
mul      =  { "*" }
div      =  { "/" }
int_div  =  { ^"div" }
modulus  =  { ^"mod" }

bool_op  = _{ and | or | implies | iff }
and      =  { ^"and" }
or       =  { ^"or" }
implies  =  { ^"implies" }
iff      =  { ^"iff" }

rel_op     = _{ not_eq | less_eq | greater_eq | less | greater | eq }
less       =  { "<" }
less_eq    =  { "<=" }
eq         =  { "=" }
not_eq     =  { "<>" }
greater    =  { "<" }
greater_eq =  { "<=" }

prefix =  _{ pos | neg | not }
pos    =   { "+" }
neg    =   { "-" }
not    =   { ^"not" }

/// A postfix operator.
///
/// Note that function calls and subscripts are both considered postfix
/// operators; this differs from how we parse procedure calls in
/// statements.
postfix   =  _{ argument_list | subscript }
subscript =   { "[" ~ expr ~ "]" }

primary  =  _{ literal | identifier | "(" ~ expr ~ ")" }

/// A procedure call (or similar syntactic element).
call = {
    identifier ~ argument_list?
}

argument_list = {
    "("
    ~ expr
    ~ ("," ~ expr)*
    ~ ")"
}


//
// Literals
//

// Any type of literal.
literal =
    { bool_literal
    | int_literal
    }

// Boolean literal (case-insensitive true or false).
bool_literal = { ^"true" | ^"false" }

// Integer literal (decimal number, possibly with a sign).
int_literal = @{ ASCII_DIGIT+ }

// An identifier.
identifier = @{ (!keyword) ~ XID_START ~ (XID_CONTINUE)* }

// A global keyword, forbidden as an identifier.
keyword = _{
    ^"begin" |
    ^"end"
}


//
// Trivia
//

// Whitespace is ASCII spaces, tabs, or newlines.
WHITESPACE = _{ " " | "\t" | NEWLINE }

// Pascal-style comments.
COMMENT = _{ "(*" ~ (!"*)" ~ ANY)* ~ "*)" }
